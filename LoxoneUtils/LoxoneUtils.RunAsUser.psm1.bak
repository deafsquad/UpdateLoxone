$script:source = @"
using Microsoft.Win32.SafeHandles;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Diagnostics; // Added for potential future logging
using System.ComponentModel; // Added for Win32Exception
using System.Xml; // Added for CLIXML parsing
using System.IO; // Added for pipe reading
using System.Threading; // Added for pipe reading threads

namespace RunAsUser
{
    internal class NativeHelpers
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct LUID
        {
            public int LowPart;
            public int HighPart;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct LUID_AND_ATTRIBUTES
        {
            public LUID Luid;
            public PrivilegeAttributes Attributes;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)] // Added CharSet
        public struct STARTUPINFO
        {
            public int cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_PRIVILEGES
        {
            public int PrivilegeCount;
            // Define privileges on the fly based on count
            // This is just a placeholder for size calculation if needed
            public LUID_AND_ATTRIBUTES Privilege1;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct WTS_SESSION_INFO
        {
            public readonly UInt32 SessionID;
            [MarshalAs(UnmanagedType.LPStr)]
            public readonly string pWinStationName;
            public readonly WTS_CONNECTSTATE_CLASS State;
        }
        [StructLayout(LayoutKind.Sequential)] // Added StructLayout
        public struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public int bInheritHandle; // Changed to int (0 or 1 often used)
        }
        // --- Added for Username Logging ---
        [StructLayout(LayoutKind.Sequential)]
        public struct SID_AND_ATTRIBUTES {
            public IntPtr Sid;
            public uint Attributes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct TOKEN_USER {
            public SID_AND_ATTRIBUTES User;
        }
        // --- End Added for Username Logging ---
        // --- Added for Username Logging ---
        public enum SID_NAME_USE {
            SidTypeUser = 1,
            SidTypeGroup,
            SidTypeDomain,
            SidTypeAlias,
            SidTypeWellKnownGroup,
            SidTypeDeletedAccount,
            SidTypeInvalid,
            SidTypeUnknown,
            SidTypeComputer
        }
        // --- End Added for Username Logging ---
    }
    internal class NativeMethods
    {
        [DllImport("kernel32", SetLastError = true)]
        public static extern uint WaitForSingleObject(
          IntPtr hHandle,
          uint dwMilliseconds); // Changed to uint

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool CloseHandle(
            IntPtr hObject); // Changed name for clarity

        [DllImport("userenv.dll", SetLastError = true)]
        public static extern bool CreateEnvironmentBlock(
            ref IntPtr lpEnvironment,
            SafeHandle hToken, // Use SafeHandle base class
            bool bInherit);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CreateProcessAsUserW(
            SafeHandle hToken, // Use SafeHandle
            string lpApplicationName,
            StringBuilder lpCommandLine, // Use StringBuilder for mutable string
            ref NativeHelpers.SECURITY_ATTRIBUTES lpProcessAttributes, // Pass struct by ref
            ref NativeHelpers.SECURITY_ATTRIBUTES lpThreadAttributes, // Pass struct by ref
            bool bInheritHandles, // Changed name for clarity
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref NativeHelpers.STARTUPINFO lpStartupInfo, // Pass struct by ref
            out NativeHelpers.PROCESS_INFORMATION lpProcessInformation); // Pass struct by out

        [DllImport("userenv.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DestroyEnvironmentBlock(
            IntPtr lpEnvironment);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool DuplicateTokenEx(
            SafeHandle ExistingTokenHandle, // Use SafeHandle
            uint dwDesiredAccess, // Typically uses constants like TOKEN_DUPLICATE | TOKEN_QUERY
            ref NativeHelpers.SECURITY_ATTRIBUTES lpTokenAttributes, // Pass struct by ref
            SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
            TOKEN_TYPE TokenType,
            out SafeNativeHandle DuplicateTokenHandle); // Use SafeNativeHandle

        [DllImport("kernel32")]
        public static extern IntPtr GetCurrentProcess();

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool GetTokenInformation(
            SafeHandle TokenHandle, // Use SafeHandle
            uint TokenInformationClass, // TOKEN_INFORMATION_CLASS enum value
            SafeMemoryBuffer TokenInformation, // Use SafeMemoryBuffer
            int TokenInformationLength,
            out int ReturnLength);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool LookupPrivilegeName(
            string lpSystemName,
            ref NativeHelpers.LUID lpLuid, // Pass LUID by ref
            StringBuilder lpName,
            ref int cchName);

        [DllImport("advapi32.dll", SetLastError = true)]
        public static extern bool OpenProcessToken(
            IntPtr ProcessHandle,
            TokenAccessLevels DesiredAccess, // Use TokenAccessLevels enum
            out SafeNativeHandle TokenHandle); // Use SafeNativeHandle

        [DllImport("wtsapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        public static extern bool WTSEnumerateSessions(
            IntPtr hServer,
            int Reserved, // Should be 0
            int Version,  // Should be 1
            ref IntPtr ppSessionInfo,
            ref int pCount);

        [DllImport("wtsapi32.dll")]
        public static extern void WTSFreeMemory(
            IntPtr pMemory);

        [DllImport("kernel32.dll")]
        public static extern uint WTSGetActiveConsoleSessionId();

        [DllImport("Wtsapi32.dll", SetLastError = true)]
        public static extern bool WTSQueryUserToken(
            uint SessionId,
            out SafeNativeHandle phToken); // Use SafeNativeHandle

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CreatePipe(
            ref IntPtr hReadPipe, // Changed to IntPtr for easier management
            ref IntPtr hWritePipe, // Changed to IntPtr
            ref NativeHelpers.SECURITY_ATTRIBUTES lpPipeAttributes, // Pass struct by ref
            int nSize); // 0 for default buffer size

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool SetHandleInformation(
            IntPtr hObject, // Use IntPtr
            int dwMask, // HANDLE_FLAG constants (e.g., HANDLE_FLAG_INHERIT)
            int dwFlags); // Flags to set (0 to remove)

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool ReadFile(
            IntPtr hFile, // Use IntPtr
            [Out] byte[] lpBuffer, // Output buffer
            int nNumberOfBytesToRead,
            ref int lpNumberOfBytesRead, // Use ref for bytes read
            IntPtr lpOverlapped); // Typically IntPtr.Zero for synchronous operations


        // DuplicateHandle signature seems problematic. The ushort might be wrong.
        // Usually, source/target handles are IntPtr. Let's assume IntPtr for now.
        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool DuplicateHandle(IntPtr hSourceProcessHandle,
           IntPtr hSourceHandle, // Changed ushort to IntPtr
           IntPtr hTargetProcessHandle,
           out IntPtr lpTargetHandle,
           uint dwDesiredAccess,
           [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle,
           uint dwOptions); // DUPLICATE_SAME_ACCESS, DUPLICATE_CLOSE_SOURCE
        // --- Added for Username Logging ---
        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern bool LookupAccountSid(
            string lpSystemName, // null for local system
            IntPtr Sid,
            StringBuilder lpName,
            ref uint cchName,
            StringBuilder ReferencedDomainName,
            ref uint cchReferencedDomainName,
            out NativeHelpers.SID_NAME_USE peUse);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool ConvertSidToStringSid(
            IntPtr pSID,
            out IntPtr ptrSid); // Use IntPtr for string pointer

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr LocalFree(IntPtr hMem);
        // --- End Added for Username Logging ---

        [DllImport("advapi32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool AdjustTokenPrivileges(
            SafeHandle TokenHandle,
            [MarshalAs(UnmanagedType.Bool)] bool DisableAllPrivileges,
            SafeMemoryBuffer NewState, // Pass buffer containing the struct
            int BufferLength, // Size of NewState buffer
            SafeMemoryBuffer PreviousState, // Optional buffer to receive previous state
            out int ReturnLength); // Required size if PreviousState is too small

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool LookupPrivilegeValue(
            string lpSystemName, // null for local machine
            string lpName, // Privilege name (e.g., "SeTcbPrivilege")
            out NativeHelpers.LUID lpLuid); // Receives LUID
    }

    // SafeHandle wrapper for HGLOBAL memory allocated by Marshal.AllocHGlobal
    internal class SafeMemoryBuffer : SafeHandleZeroOrMinusOneIsInvalid
    {
        // Constructor for allocating memory
        public SafeMemoryBuffer(int cb) : base(true)
        {
            base.SetHandle(Marshal.AllocHGlobal(cb));
            // Consider adding capacity property if needed
        }

        // Constructor for existing handle (use with caution, ensure ownership is transferred)
        public SafeMemoryBuffer(IntPtr handle) : base(true)
        {
            base.SetHandle(handle);
        }

        // Constructor needed for P/Invoke GetTokenInformation (size = 0 case)
        private SafeMemoryBuffer() : base(true) { }


        protected override bool ReleaseHandle()
        {
            if (handle != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(handle);
                handle = IntPtr.Zero; // Mark as freed
                return true;
            }
            return false; // Already freed or never allocated
        }
    }

    // SafeHandle wrapper for native handles closed with CloseHandle
    internal class SafeNativeHandle : SafeHandleZeroOrMinusOneIsInvalid
    {
        // Private constructor for P/Invoke to use.
        private SafeNativeHandle() : base(true) { }

        // Public constructor if needed (e.g., wrapping an existing handle)
        public SafeNativeHandle(IntPtr handle) : base(true)
        {
            SetHandle(handle);
        }

        // Allows checking if the handle is valid (non-zero, non-invalid)
        public bool IsValid // Replaced expression body for C# 5 compatibility
        {
            get { return !IsInvalid && !IsClosed; }
        }


        protected override bool ReleaseHandle()
        {
            return NativeMethods.CloseHandle(handle);
        }
    }
    internal enum SECURITY_IMPERSONATION_LEVEL
    {
        SecurityAnonymous = 0,
        SecurityIdentification = 1,
        SecurityImpersonation = 2,
        SecurityDelegation = 3,
    }
    internal enum SW // ShowWindow Commands
    {
        SW_HIDE = 0,
        SW_SHOWNORMAL = 1,
        SW_NORMAL = 1,
        SW_SHOWMINIMIZED = 2,
        SW_SHOWMAXIMIZED = 3,
        SW_MAXIMIZE = 3,
        SW_SHOWNOACTIVATE = 4,
        SW_SHOW = 5,
        SW_MINIMIZE = 6,
        SW_SHOWMINNOACTIVE = 7,
        SW_SHOWNA = 8,
        SW_RESTORE = 9,
        SW_SHOWDEFAULT = 10,
        SW_MAX = 10 // Note: Some sources say SW_FORCEMINIMIZE is 11
    }

    // TOKEN_INFORMATION_CLASS subset needed
    internal enum TokenInformationClass
    {
         TokenUser = 1,
         TokenGroups = 2,
         TokenPrivileges = 3,
         // ... other values
         TokenElevationType = 18,
         TokenLinkedToken = 19,
         TokenSessionId = 12,
         // ... other values
    }


    internal enum TokenElevationType
    {
        TokenElevationTypeDefault = 1,
        TokenElevationTypeFull,
        TokenElevationTypeLimited,
    }
    internal enum TOKEN_TYPE
    {
        TokenPrimary = 1,
        TokenImpersonation = 2
    }
    internal enum WTS_CONNECTSTATE_CLASS
    {
        WTSActive,
        WTSConnected,
        WTSConnectQuery,
        WTSShadow,
        WTSDisconnected,
        WTSIdle,
        WTSListen,
        WTSReset,
        WTSDown,
        WTSInit
    }
    [Flags]
    public enum PrivilegeAttributes : uint
    {
        Disabled = 0x00000000,
        EnabledByDefault = 0x00000001,
        Enabled = 0x00000002,
        Removed = 0x00000004,
        UsedForAccess = 0x80000000,
    }

    [Flags]
    public enum TokenAccessLevels : uint
    {
        AssignPrimary = 0x0001,
        Duplicate = 0x0002,
        Impersonate = 0x0004,
        Query = 0x0008,
        QuerySource = 0x0010,
        AdjustPrivileges = 0x0020,
        AdjustGroups = 0x0040,
        AdjustDefault = 0x0080,
        AdjustSessionId = 0x0100,
        Read = 0x00020000 | Query, // STANDARD_RIGHTS_READ | Query
        Write = 0x00020000 | AdjustPrivileges | AdjustGroups | AdjustDefault, // STANDARD_RIGHTS_WRITE | AdjustPrivileges | AdjustGroups | AdjustDefault
        AllAccess = 0x000F0000 | AssignPrimary | Duplicate | Impersonate | Query | QuerySource | AdjustPrivileges | AdjustGroups | AdjustDefault | AdjustSessionId // STANDARD_RIGHTS_REQUIRED | ...
    }


    public static class ProcessExtensions
    {
        #region Win32 Constants
        // Creation Flags for CreateProcessAsUser
        private const uint CREATE_UNICODE_ENVIRONMENT = 0x00000400;
        private const uint CREATE_NO_WINDOW = 0x08000000;
        private const uint CREATE_NEW_CONSOLE = 0x00000010;
        private const uint CREATE_BREAKAWAY_FROM_JOB = 0x01000000; // Allows process to run outside the job object of the parent
        private const uint NORMAL_PRIORITY_CLASS = 0x00000020;


        private const uint INVALID_SESSION_ID = 0xFFFFFFFF;
        private static readonly IntPtr WTS_CURRENT_SERVER_HANDLE = IntPtr.Zero;

        // Handle Flags
        private const int HANDLE_FLAG_INHERIT = 0x00000001;
        private const int HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002;

        // STARTUPINFO Flags
        private const uint STARTF_USESTDHANDLES = 0x00000100;

        // Token Access Rights
        private const uint TOKEN_QUERY = 0x0008;
        private const uint TOKEN_DUPLICATE = 0x0002;
        private const uint TOKEN_ASSIGN_PRIMARY = 0x0001;
        private const uint TOKEN_ADJUST_PRIVILEGES = 0x0020;
        private const uint TOKEN_ADJUST_GROUPS = 0x0040;
        private const uint TOKEN_ADJUST_DEFAULT = 0x0080;
        private const uint TOKEN_ADJUST_SESSIONID = 0x0100;
        private const uint TOKEN_ALL_ACCESS = (uint)TokenAccessLevels.AllAccess; // Cast enum to uint for const
        private const uint TOKEN_READ = (uint)TokenAccessLevels.Read; // Cast enum to uint for const
        private const uint TOKEN_WRITE = (uint)TokenAccessLevels.Write; // Cast enum to uint for const

        // Other constants
        private const int ERROR_INSUFFICIENT_BUFFER = 122;
        private const int ERROR_BAD_LENGTH = 24; // Sometimes returned instead of 122
        private const int BUFSIZE = 4096; // Buffer for pipe reads
        private const uint ERROR_BROKEN_PIPE = 109; // Expected error when pipe is closed


        #endregion

        // Gets the primary user token for the currently active user session.
        private static SafeNativeHandle GetSessionUserToken(bool getElevatedToken)
        {
            uint activeSessionId = INVALID_SESSION_ID;
            IntPtr pSessionInfo = IntPtr.Zero;
            int sessionCount = 0;

            // Try enumerating sessions to find the active one.
            if (NativeMethods.WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, ref pSessionInfo, ref sessionCount))
            {
                try
                {
                    IntPtr current = pSessionInfo;
                    int dataSize = Marshal.SizeOf(typeof(NativeHelpers.WTS_SESSION_INFO));
                    for (int i = 0; i < sessionCount; i++)
                    {
                        NativeHelpers.WTS_SESSION_INFO si = (NativeHelpers.WTS_SESSION_INFO)Marshal.PtrToStructure(current, typeof(NativeHelpers.WTS_SESSION_INFO));
                        current = IntPtr.Add(current, dataSize); // Move pointer to next struct
                        if (si.State == WTS_CONNECTSTATE_CLASS.WTSActive)
                        {
                            activeSessionId = si.SessionID;
                            // Console.WriteLine(string.Format("DEBUG: Found active session {0} via WTSEnumerateSessions.", activeSessionId)); // Commented out
                            break;
                        }
                    }
                }
                finally
                {
                    NativeMethods.WTSFreeMemory(pSessionInfo);
                }
            }
            else
            {
                 int error = Marshal.GetLastWin32Error();
                 // Console.WriteLine(string.Format("[WARNING] WTSEnumerateSessions failed with code: {0}. Falling back...", error)); // Commented out
            }


            // Fallback if enumeration failed or no active session was found
            if (activeSessionId == INVALID_SESSION_ID)
            {
                activeSessionId = NativeMethods.WTSGetActiveConsoleSessionId();
                if (activeSessionId == INVALID_SESSION_ID) // 0xFFFFFFFF
                {
                     // This can happen if no user is logged in or in certain service contexts.
                     throw new Win32Exception("Could not get active console session ID. No user might be logged on.");
                }
                // Console.WriteLine(string.Format("DEBUG: Using active console session ID: {0} (fallback).", activeSessionId)); // Commented out
            }
            // Console.WriteLine(string.Format("DEBUG_CS_SESSION: Target Session ID is {0}", activeSessionId)); // Commented out

            SafeNativeHandle hImpersonationToken;
            if (!NativeMethods.WTSQueryUserToken(activeSessionId, out hImpersonationToken))
            {
                int error = Marshal.GetLastWin32Error();
                // Console.WriteLine(string.Format("[ERROR] WTSQueryUserToken failed for session {0}. Error Code: {1}", activeSessionId, error)); // Commented out
                throw new Win32Exception(error, string.Format("WTSQueryUserToken failed for session {0}", activeSessionId));
            }

            // WTSQueryUserToken returns an impersonation token. We need a primary token for CreateProcessAsUser.
            using (hImpersonationToken) // Ensure impersonation token is disposed
            {
                 if (getElevatedToken)
                 {
                     try 
                     {
                         TokenElevationType elevationType = GetTokenElevationType(hImpersonationToken);
                         if (elevationType == TokenElevationType.TokenElevationTypeLimited)
                         {
                             // Console.WriteLine("DEBUG: Current token is limited, attempting to get linked elevated token."); // Commented out
                             using (SafeNativeHandle linkedToken = GetTokenLinkedToken(hImpersonationToken))
                             {
                                 // If we successfully get the linked token, duplicate THAT as primary
                                 return DuplicateTokenAsPrimary(linkedToken); 
                             }
                         }
                         // If token is already full or default, we fall through
                     } 
                     catch (Win32Exception ex) when (ex.NativeErrorCode == 1312) // ERROR_NO_SUCH_LOGON_SESSION 
                     {
                         // Expected error if no linked token exists (e.g., UAC off, or already elevated). Fall through.
                         // Console.WriteLine("[WARNING] Could not get linked token (Error 1312). Proceeding with the current token."); // Commented out
                     }
                     catch (Exception ex) 
                     {
                         // Log other unexpected errors during elevation check but still fall through
                         // Console.WriteLine(string.Format("[WARNING] Error checking/getting linked token: {0}. Proceeding with the current token.", ex.Message)); // Commented out
                     }
                 } 
                 // If not requesting elevation, or if getting elevated token failed/was unnecessary, duplicate the original impersonation token.
                 return DuplicateTokenAsPrimary(hImpersonationToken);
            } // Closes 'using (hImpersonationToken)'
        }

        // Helper to duplicate an impersonation token into a primary token
        private static SafeNativeHandle DuplicateTokenAsPrimary(SafeHandle hImpersonationToken)
        {
            SafeNativeHandle hPrimaryToken;
            NativeHelpers.SECURITY_ATTRIBUTES sa = new NativeHelpers.SECURITY_ATTRIBUTES();
            sa.nLength = Marshal.SizeOf(sa);

            if (!NativeMethods.DuplicateTokenEx(
                    hImpersonationToken,
                    TOKEN_ALL_ACCESS, // Request maximum allowed access
                    ref sa,
                    SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, // Doesn't matter much for primary token
                    TOKEN_TYPE.TokenPrimary,
                    out hPrimaryToken))
            {
                int error = Marshal.GetLastWin32Error();
                // Console.WriteLine(string.Format("[ERROR] DuplicateTokenEx failed with code: {0}", error)); // Commented out
                throw new Win32Exception(error, "DuplicateTokenEx failed to create primary token.");
            }
            // Console.WriteLine("DEBUG: Duplicated token as primary successfully."); // Commented out
            return hPrimaryToken;
        }

        // Helper to get TokenElevationType
        private static TokenElevationType GetTokenElevationType(SafeHandle hToken)
        {
            int elevationTypeSize = sizeof(TokenElevationType);
            using (SafeMemoryBuffer pElevationType = new SafeMemoryBuffer(elevationTypeSize))
            {
                int returnLength;
                if (!NativeMethods.GetTokenInformation(hToken, (uint)TokenInformationClass.TokenElevationType, pElevationType, elevationTypeSize, out returnLength))
                {
                    throw new Win32Exception(Marshal.GetLastWin32Error(), "GetTokenInformation (TokenElevationType) failed.");
                }
                return (TokenElevationType)Marshal.ReadInt32(pElevationType.DangerousGetHandle());
            }
        }

        // Helper to get Linked Token
        private static SafeNativeHandle GetTokenLinkedToken(SafeHandle hToken)
        {
            int linkedTokenSize = Marshal.SizeOf(typeof(IntPtr)); // Size of TOKEN_LINKED_TOKEN is just an IntPtr (handle)
            using (SafeMemoryBuffer pLinkedToken = new SafeMemoryBuffer(linkedTokenSize))
            {
                int returnLength;
                if (!NativeMethods.GetTokenInformation(hToken, (uint)TokenInformationClass.TokenLinkedToken, pLinkedToken, linkedTokenSize, out returnLength))
                {
                    throw new Win32Exception(Marshal.GetLastWin32Error(), "GetTokenInformation (TokenLinkedToken) failed.");
                }
                IntPtr linkedTokenHandle = Marshal.ReadIntPtr(pLinkedToken.DangerousGetHandle());
                return new SafeNativeHandle(linkedTokenHandle); // Wrap the raw handle
            }
        }

        // Helper to enable/disable privileges
        private static bool SetPrivilege(SafeHandle hToken, string privilegeName, bool enablePrivilege)
        {
            NativeHelpers.LUID luid;
            if (!NativeMethods.LookupPrivilegeValue(null, privilegeName, out luid))
            {
                // Console.WriteLine(string.Format("[ERROR] LookupPrivilegeValue failed for {0}. Error: {1}", privilegeName, Marshal.GetLastWin32Error())); // Commented out
                return false;
            }

            NativeHelpers.TOKEN_PRIVILEGES tp = new NativeHelpers.TOKEN_PRIVILEGES();
            tp.PrivilegeCount = 1;
            // tp.Privileges = new NativeHelpers.LUID_AND_ATTRIBUTES[1]; // Allocate array - Not needed for single privilege adjustment with this struct layout
            tp.Privilege1.Luid = luid; // Assign directly to the embedded struct member
            tp.Privilege1.Attributes = enablePrivilege ? PrivilegeAttributes.Enabled : PrivilegeAttributes.Disabled;

            // Allocate buffer for TOKEN_PRIVILEGES structure
            int tpSize = Marshal.SizeOf(typeof(NativeHelpers.TOKEN_PRIVILEGES));
            using (SafeMemoryBuffer tpBuffer = new SafeMemoryBuffer(tpSize))
            {
                 Marshal.StructureToPtr(tp, tpBuffer.DangerousGetHandle(), false); // Marshal struct to buffer

                 int returnLength; // Dummy variable
                 bool success = NativeMethods.AdjustTokenPrivileges(hToken, false, tpBuffer, tpSize, null, out returnLength); // Pass buffer
                 int error = Marshal.GetLastWin32Error();

                 if (!success || error != 0) // Check error code even if AdjustTokenPrivileges returns true (it might indicate partial success/failure)
                 {
                     // Console.WriteLine(string.Format("[ERROR] AdjustTokenPrivileges failed for {0}. Success: {1}, Error: {2}", privilegeName, success, error)); // Commented out
                     return false;
                 }
            } // using tpBuffer ensures memory is freed

            // Console.WriteLine(string.Format("DEBUG: Privilege '{0}' {1} attempt finished.", privilegeName, (enablePrivilege ? "enable" : "disable"))); // Commented out
            return true;
        }


        // --- Pipe Reading Thread ---
        private class PipeReader
        {
            private IntPtr pipeHandle;
            private StringBuilder outputBuilder;
            private string streamName; // "StdOut" or "StdErr" for logging

            public PipeReader(IntPtr handle, StringBuilder builder, string name)
            {
                pipeHandle = handle;
                outputBuilder = builder;
                streamName = name;
            }

            public void ReadPipe()
            {
                byte[] buffer = new byte[BUFSIZE];
                int bytesRead = 0;
                SafeNativeHandle safePipeHandle = new SafeNativeHandle(pipeHandle); // Wrap for safety

                // Console.WriteLine(string.Format("DEBUG: Reading from {0} pipe...", streamName)); // Commented out
                try
                {
                    while (safePipeHandle != null && !safePipeHandle.IsInvalid && !safePipeHandle.IsClosed)
                    {
                        bytesRead = 0;
                        bool readFileSuccess = NativeMethods.ReadFile(safePipeHandle.DangerousGetHandle(), buffer, BUFSIZE, ref bytesRead, IntPtr.Zero);

                        if (readFileSuccess && bytesRead > 0)
                        {
                            outputBuilder.Append(Encoding.UTF8.GetString(buffer, 0, bytesRead));
                        }
                        else
                        {
                            int lastError = Marshal.GetLastWin32Error();
                            if (lastError == ERROR_BROKEN_PIPE || !readFileSuccess)
                            {
                                // Console.WriteLine(string.Format("DEBUG: {0} pipe read finished or broken (Error: {1}). Breaking read loop.", streamName, lastError)); // Commented out
                                break;
                            }
                            // If ReadFile returns true but bytesRead is 0, it means EOF on the pipe.
                            // Console.WriteLine(string.Format("DEBUG: {0} pipe read returned 0 bytes (EOF). Breaking read loop.", streamName)); // Commented out
                            break;
                        }
                    }
                }
                catch (Exception) // Catch other non-Win32 exceptions
                {
                     // Console.WriteLine(string.Format("[ERROR] Exception during {0} pipe read: {1}", streamName, "N/A")); // Commented out, removed ex.Message
                }
                finally
                {
                    if (safePipeHandle != null) safePipeHandle.Close(); // Ensure handle is closed
                    // Console.WriteLine(string.Format("DEBUG: Finished reading {0} pipe. Read {1} chars.", streamName, outputBuilder.Length)); // Commented out
                }
            }
        }
        // --- End Pipe Reading Thread ---


        // Main function to start process
        public static string StartProcessAsCurrentUser(string appPath, string cmdLine = null, string workDir = null, bool visible = true, int wait = -1, bool elevated = true, bool redirectOutput = true, bool breakaway = false, string scriptBlock = null)
        {
            string result = string.Empty;
            SafeNativeHandle primaryToken = null;
            IntPtr pEnv = IntPtr.Zero; // Initialize pEnv
            NativeHelpers.PROCESS_INFORMATION procInfo = new NativeHelpers.PROCESS_INFORMATION();
            NativeHelpers.STARTUPINFO startInfo = new NativeHelpers.STARTUPINFO();
            IntPtr out_read_ptr = IntPtr.Zero, out_write_ptr = IntPtr.Zero;
            IntPtr err_read_ptr = IntPtr.Zero, err_write_ptr = IntPtr.Zero;
            SafeNativeHandle out_read = null, out_write = null;
            SafeNativeHandle err_read = null, err_write = null;
            Thread stdoutReaderThread = null;
            Thread stderrReaderThread = null;
            StringBuilder outputBuilder = null;
            StringBuilder errorBuilder = null;


            try
            {
                 // Console.WriteLine(string.Format("DEBUG: Entered StartProcessAsCurrentUser C#. App: '{0}', Elevated: {1}, Redirect: {2}", appPath, elevated, redirectOutput)); // Commented out
                 primaryToken = GetSessionUserToken(elevated);

                 // --- Log User Info ---
                 try
                 {
                     int tokenInfoLength = 0;
                     NativeMethods.GetTokenInformation(primaryToken, (uint)TokenInformationClass.TokenUser, null, 0, out tokenInfoLength);
                     int error = Marshal.GetLastWin32Error();
                     if (error == ERROR_INSUFFICIENT_BUFFER || error == ERROR_BAD_LENGTH)
                     {
                         using (SafeMemoryBuffer tokenInfo = new SafeMemoryBuffer(tokenInfoLength))
                         {
                             if (NativeMethods.GetTokenInformation(primaryToken, (uint)TokenInformationClass.TokenUser, tokenInfo, tokenInfoLength, out tokenInfoLength))
                             {
                                 NativeHelpers.TOKEN_USER tokenUser = (NativeHelpers.TOKEN_USER)Marshal.PtrToStructure(tokenInfo.DangerousGetHandle(), typeof(NativeHelpers.TOKEN_USER));
                                 uint nameSize = 0, domainNameSize = 0; NativeHelpers.SID_NAME_USE sidUse;
                                 NativeMethods.LookupAccountSid(null, tokenUser.User.Sid, null, ref nameSize, null, ref domainNameSize, out sidUse);
                                 error = Marshal.GetLastWin32Error();
                                 if (error == ERROR_INSUFFICIENT_BUFFER)
                                 {
                                     StringBuilder name = new StringBuilder((int)nameSize); StringBuilder domainName = new StringBuilder((int)domainNameSize);
                                     if (NativeMethods.LookupAccountSid(null, tokenUser.User.Sid, name, ref nameSize, domainName, ref domainNameSize, out sidUse))
                                         { /* Console.WriteLine(string.Format("DEBUG_CS_USER: Running under token for user: {0}\\{1} (SID Type: {2})", domainName.ToString(), name.ToString(), sidUse)); */ } // Commented out
                                     else { error = Marshal.GetLastWin32Error(); /* Console.WriteLine(string.Format("DEBUG_CS_USER: LookupAccountSid (data retrieval) failed. Error Code: {0}", error)); */ } // Commented out
                                 } else { /* Console.WriteLine(string.Format("DEBUG_CS_USER: LookupAccountSid (size query) failed. Error Code: {0}", error)); */ } // Commented out
                             } else { error = Marshal.GetLastWin32Error(); /* Console.WriteLine(string.Format("DEBUG_CS_USER: GetTokenInformation (TokenUser data retrieval) failed. Error Code: {0}", error)); */ } // Commented out
                         }
                     } else { /* Console.WriteLine(string.Format("DEBUG_CS_USER: GetTokenInformation (TokenUser size query) failed. Error Code: {0}", error)); */ } // Commented out
                 } catch (Exception) { /* Console.WriteLine(string.Format("DEBUG_CS_USER: Exception during username lookup: {0}", "N/A")); */ } // Commented out, removed ex.Message
                 // --- End Log User Info ---


                 // --- Environment Block Handling ---
                 // Create the environment block for the target user token
                 if (!NativeMethods.CreateEnvironmentBlock(ref pEnv, primaryToken, false))
                 {
                     int error = Marshal.GetLastWin32Error();
                     // Console.WriteLine(string.Format("[ERROR] CreateEnvironmentBlock failed with code: {0}", error)); // Commented out
                     throw new Win32Exception(error, "CreateEnvironmentBlock failed.");
                 }
                 // Console.WriteLine("DEBUG: Environment block created."); // Commented out
                 // --- End Environment Block Handling ---


                 if (redirectOutput)
                 {
                     outputBuilder = new StringBuilder();
                     errorBuilder = new StringBuilder();
                     NativeHelpers.SECURITY_ATTRIBUTES saAttr = new NativeHelpers.SECURITY_ATTRIBUTES { nLength = Marshal.SizeOf(typeof(NativeHelpers.SECURITY_ATTRIBUTES)), bInheritHandle = 1, lpSecurityDescriptor = IntPtr.Zero };
                     if (!NativeMethods.CreatePipe(ref out_read_ptr, ref out_write_ptr, ref saAttr, 0)) throw new Win32Exception(Marshal.GetLastWin32Error(), "CreatePipe (stdout) failed.");
                     if (!NativeMethods.CreatePipe(ref err_read_ptr, ref err_write_ptr, ref saAttr, 0)) throw new Win32Exception(Marshal.GetLastWin32Error(), "CreatePipe (stderr) failed.");
                     out_read = new SafeNativeHandle(out_read_ptr); out_write = new SafeNativeHandle(out_write_ptr); err_read = new SafeNativeHandle(err_read_ptr); err_write = new SafeNativeHandle(err_write_ptr);
                     if (!NativeMethods.SetHandleInformation(out_read.DangerousGetHandle(), HANDLE_FLAG_INHERIT, 0)) throw new Win32Exception(Marshal.GetLastWin32Error(), "SetHandleInformation (stdout read) failed.");
                     if (!NativeMethods.SetHandleInformation(err_read.DangerousGetHandle(), HANDLE_FLAG_INHERIT, 0)) throw new Win32Exception(Marshal.GetLastWin32Error(), "SetHandleInformation (stderr read) failed.");
                     startInfo.dwFlags = STARTF_USESTDHANDLES; startInfo.hStdOutput = out_write.DangerousGetHandle(); startInfo.hStdError = err_write.DangerousGetHandle(); startInfo.hStdInput = IntPtr.Zero;
                     // Console.WriteLine("DEBUG: Pipes created and configured for redirection."); // Commented out
                 } else { /* Console.WriteLine("DEBUG: Output redirection disabled."); */ } // Commented out

                 startInfo.cb = Marshal.SizeOf(startInfo); startInfo.lpDesktop = @"winsta0\default";
                 // Console.WriteLine(string.Format("DEBUG_CS_DESKTOP: STARTUPINFO.lpDesktop set to: {0}", (startInfo.lpDesktop != null ? startInfo.lpDesktop : "null"))); // Commented out
                 startInfo.wShowWindow = visible ? (short)SW.SW_SHOWNORMAL : (short)SW.SW_SHOWMINNOACTIVE;

                 uint dwCreationFlags = CREATE_UNICODE_ENVIRONMENT | NORMAL_PRIORITY_CLASS; // Keep CREATE_UNICODE_ENVIRONMENT
                 if (breakaway) { dwCreationFlags |= CREATE_BREAKAWAY_FROM_JOB; /* Console.WriteLine("DEBUG: CREATE_BREAKAWAY_FROM_JOB flag set."); */ } // Commented out

                 NativeHelpers.SECURITY_ATTRIBUTES procSecAttrs = new NativeHelpers.SECURITY_ATTRIBUTES { nLength = Marshal.SizeOf(typeof(NativeHelpers.SECURITY_ATTRIBUTES)) };
                 NativeHelpers.SECURITY_ATTRIBUTES threadSecAttrs = new NativeHelpers.SECURITY_ATTRIBUTES { nLength = Marshal.SizeOf(typeof(NativeHelpers.SECURITY_ATTRIBUTES)) };

                 string applicationToLaunch = appPath;
                 StringBuilder finalCommandLine = new StringBuilder();
                 if (!string.IsNullOrEmpty(scriptBlock))
                 {
                     // If scriptBlock is provided, assume appPath is powershell.exe and build command line
                     applicationToLaunch = Environment.ExpandEnvironmentVariables(@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe");
                     string encodedCommand = Convert.ToBase64String(Encoding.Unicode.GetBytes(scriptBlock));
                     finalCommandLine.AppendFormat("-NoProfile -NonInteractive -ExecutionPolicy Bypass -EncodedCommand {0}", encodedCommand);
                     // Console.WriteLine("DEBUG: Using PowerShell with EncodedCommand for script block."); // Commented out
                 }
                 else if (!string.IsNullOrEmpty(cmdLine))
                 {
                     // If cmdLine is provided, use it directly
                     finalCommandLine.Append(cmdLine);
                     // Console.WriteLine("DEBUG: Using provided appPath and cmdLine."); // Commented out
                 }
                 else
                 {
                     // If only appPath is provided, use it as the executable
                     // Console.WriteLine("DEBUG: Using provided appPath only."); // Commented out
                 }


                 // Console.WriteLine(string.Format("DEBUG: Calling CreateProcessAsUserW. App: '{0}', CmdLine: '{1}', Dir: '{2}', Flags: {3}", applicationToLaunch, finalCommandLine.ToString(), (workDir != null ? workDir : "Default"), dwCreationFlags)); // Commented out
                 // Console.WriteLine(string.Format("DEBUG_CS_STARTINFO: lpDesktop='{0}', dwFlags={1}, wShowWindow={2}", startInfo.lpDesktop, startInfo.dwFlags, startInfo.wShowWindow)); // Commented out

                 bool processCreated = NativeMethods.CreateProcessAsUserW(
                      primaryToken, applicationToLaunch, finalCommandLine, ref procSecAttrs, ref threadSecAttrs,
                      redirectOutput, dwCreationFlags, pEnv, (string.IsNullOrEmpty(workDir) ? null : workDir), ref startInfo, out procInfo); // Pass pEnv

                 if (!processCreated)
                     { int error = Marshal.GetLastWin32Error(); /* Console.WriteLine(string.Format("[ERROR] CreateProcessAsUserW failed with code: {0}", error)); */ throw new Win32Exception(error, string.Format("CreateProcessAsUserW failed for App: '{0}', Command: '{1}'", applicationToLaunch, finalCommandLine.ToString())); } // Commented out
                 // Console.WriteLine(string.Format("DEBUG: Process created successfully. PID: {0}, TID: {1}", procInfo.dwProcessId, procInfo.dwThreadId)); // Commented out

                 if (redirectOutput)
                 {
                     // Close write ends of pipes in parent process immediately
                     if (out_write != null) { out_write.Close(); out_write = null; }
                     if (err_write != null) { err_write.Close(); err_write = null; }
                     // Console.WriteLine("DEBUG: Closed write ends of pipes in parent."); // Commented out

                     // Start threads to read pipes
                     PipeReader stdoutReader = new PipeReader(out_read_ptr, outputBuilder, "StdOut");
                     stdoutReaderThread = new Thread(stdoutReader.ReadPipe);
                     stdoutReaderThread.Start();

                     PipeReader stderrReader = new PipeReader(err_read_ptr, errorBuilder, "StdErr");
                     stderrReaderThread = new Thread(stderrReader.ReadPipe);
                     stderrReaderThread.Start();
                 }

                 if (procInfo.hThread != IntPtr.Zero) { NativeMethods.CloseHandle(procInfo.hThread); /* Console.WriteLine("DEBUG: Closed process's main thread handle."); */ procInfo.hThread = IntPtr.Zero; } // Commented out

                 if (wait != 0 && procInfo.hProcess != IntPtr.Zero)
                 {
                     // Console.WriteLine(string.Format("DEBUG: Waiting for process {0} to exit (timeout: {1} ms)...", procInfo.dwProcessId, wait)); // Commented out
                     uint waitResult = NativeMethods.WaitForSingleObject(procInfo.hProcess, (uint)wait);
                     // Console.WriteLine(string.Format("DEBUG: Wait finished for process {0}.", procInfo.dwProcessId)); // Commented out
                     result = string.Format("Process {0} completed.", procInfo.dwProcessId); // Default result if no redirection
                 }
                 else
                 {
                     // Console.WriteLine(string.Format("DEBUG: Process {0} started without waiting (wait=0).", procInfo.dwProcessId)); // Commented out
                     result = procInfo.dwProcessId.ToString(); // Return PID if not waiting
                 }

                 if (redirectOutput)
                 {
                     // Wait for reader threads to finish
                     if (stdoutReaderThread != null) stdoutReaderThread.Join();
                     if (stderrReaderThread != null) stderrReaderThread.Join();
                     // Console.WriteLine("DEBUG: Pipe reader threads joined."); // Commented out

                     var finalResultBuilder = new StringBuilder();
                     string stdoutContent = outputBuilder.ToString().TrimEnd('\r', '\n');
                     string rawStderrContent = errorBuilder.ToString().TrimEnd('\r', '\n');

                     if (!string.IsNullOrEmpty(stdoutContent))
                     {
                         finalResultBuilder.AppendLine("[STDOUT]");
                         finalResultBuilder.AppendLine(stdoutContent);
                     }
                     if (!string.IsNullOrEmpty(rawStderrContent))
                     {
                         // Simple append for now, XML wrapping caused issues before
                         finalResultBuilder.AppendLine("[STDERR]");
                         finalResultBuilder.AppendLine(rawStderrContent);
                     }
                     result = finalResultBuilder.ToString();
                 }

            }
            catch (Exception ex) // Keep ex variable here as it's used
            {
                 // Console.WriteLine(string.Format("[ERROR] Exception in StartProcessAsCurrentUser: {0} - {1}", ex.GetType().Name, ex.Message)); // Commented out
                 // Check if it was originally a Win32Exception by checking the message format we created OR check type directly
                 if (ex is System.ComponentModel.Win32Exception) { System.ComponentModel.Win32Exception w32ex = (System.ComponentModel.Win32Exception)ex; result = string.Format("[ERROR] Win32 Error {0}: {1}", w32ex.NativeErrorCode, w32ex.Message); }
                 else { result = string.Format("[ERROR] {0}: {1}", ex.GetType().Name, ex.Message); }
                 result = string.Format("[FAILURE] {0}", result); // Prefix failure indicator
            }
            finally
            {
                // Console.WriteLine("DEBUG: Entering final cleanup block..."); // Commented out
                // Always close process handle if it's valid
                if (procInfo.hProcess != IntPtr.Zero)
                {
                    NativeMethods.CloseHandle(procInfo.hProcess);
                    procInfo.hProcess = IntPtr.Zero;
                    // Console.WriteLine(string.Format("DEBUG: Closed process handle for PID {0} in finally.", procInfo.dwProcessId)); // Commented out
                }
                // Always close thread handle if it's valid (should normally be closed earlier)
                if (procInfo.hThread != IntPtr.Zero)
                {
                    NativeMethods.CloseHandle(procInfo.hThread);
                    procInfo.hThread = IntPtr.Zero; // Mark as closed
                    // Console.WriteLine("DEBUG: Closed process's main thread handle (in finally)."); // Commented out
                }

                // Ensure pipe handles are closed if redirection was used
                if (out_read != null) out_read.Close(); if (out_write != null) out_write.Close(); if (err_read != null) err_read.Close(); if (err_write != null) err_write.Close();
                 // if (redirectOutput) Console.WriteLine("DEBUG: Ensured pipe safe handles are closed."); // Commented out

                // Destroy environment block - only if it was created
                if (pEnv != IntPtr.Zero)
                {
                    NativeMethods.DestroyEnvironmentBlock(pEnv);
                    // Console.WriteLine("DEBUG: Destroyed environment block."); // Commented out
                    pEnv = IntPtr.Zero;
                }
                if (primaryToken != null) { primaryToken.Dispose(); /* Console.WriteLine("DEBUG: Disposed primary user token handle."); */ } // Commented out
                // Console.WriteLine("DEBUG: Exiting final cleanup block."); // Commented out
            }
            // Console.WriteLine(string.Format("DEBUG: Returning result: {0}", result)); // Commented out // Log the result being returned
            return result;
        }
    }
}
"@ # End of C# source

# --- Compile C# Code ---
# Check if type already exists to avoid errors on re-import
if (-not ([System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms"))) {
    Add-Type -AssemblyName System.Windows.Forms -ErrorAction Stop
}
if (-not ([System.Reflection.Assembly]::LoadWithPartialName("System.Drawing"))) {
    Add-Type -AssemblyName System.Drawing -ErrorAction Stop
}

if (-not ([System.Management.Automation.PSTypeName]'RunAsUser.ProcessExtensions').Type) {
    # Define path for debug log
    $debugLogPath = Join-Path $PSScriptRoot '..\Logs\runasuser_addtype_debug.log' # Relative to this module's location
    try {
        # Attempt Add-Type with error logging
        Add-Type -TypeDefinition $script:source -Language CSharp -ErrorAction Stop
        Write-Host "INFO: Add-Type for RunAsUser.ProcessExtensions succeeded." -ForegroundColor Green # Temporary feedback
    } catch {
        # Log detailed error information
        $errorDetails = $_ | Out-String
        $errorMessage = "FATAL: Add-Type failed for RunAsUser.ProcessExtensions. C# compilation likely failed. Error: $errorDetails"
        Write-Error $errorMessage
        # Write details to debug log file
        try {
            "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - Add-Type Error:`n$errorDetails`n" | Out-File -FilePath $debugLogPath -Append -Encoding UTF8
        } catch {
            Write-Warning "Failed to write Add-Type error details to '$debugLogPath': $($_.Exception.Message)"
        }
        # Stop module loading if Add-Type fails
        throw "FATAL: Type [RunAsUser.ProcessExtensions] not found after Add-Type attempt. C# compilation likely failed or type is inaccessible. Check '$debugLogPath'."
    }
} else {
     Write-Host "INFO: Type [RunAsUser.ProcessExtensions] already exists. Skipping Add-Type." -ForegroundColor Cyan # Temporary feedback
}
# --- End Compile C# Code ---


#region PowerShell Functions

# Main function exposed to the user
function Invoke-AsCurrentUser {
    [CmdletBinding(DefaultParameterSetName='FilePath')] # Define default set
    param(
        [Parameter(ParameterSetName='FilePath', Mandatory=$true)] # Assign to FilePath set, make mandatory for this set
        [string]$FilePath,

        [Parameter(ParameterSetName='FilePath', Mandatory=$false)] # Assign to FilePath set
        [string]$CommandLine,

        [Parameter(ParameterSetName='FilePath', Mandatory=$false)] # Assign to FilePath set
        [string]$WorkingDirectory,

        [Parameter(Mandatory=$false)]
        [switch]$Visible, # Removed default value

        [Parameter(Mandatory=$false)]
        [int]$WaitTimeout = -1, # Default: Wait indefinitely. 0: No wait. >0: Timeout in ms.

        [Parameter(Mandatory=$false)]
        [switch]$Elevated, # Removed default value

        [Parameter(Mandatory=$false)]
        [switch]$CaptureOutput, # If present, redirect stdout/stderr and return as string

        [Parameter(Mandatory=$false)]
        [switch]$BreakawayFromJob, # If present, use CREATE_BREAKAWAY_FROM_JOB

        [Parameter(ParameterSetName='ScriptBlock', Mandatory=$true)] # Keep ScriptBlock set definition
        [scriptblock]$ScriptBlock,

        [Parameter(ParameterSetName='ScriptBlock', Mandatory=$false)]
        [object[]]$ArgumentList # Arguments for the script block
    )

    try {
        # Prepare arguments for the C# method
        $appPathArg = $FilePath
        $cmdLineArg = $CommandLine
        $workDirArg = $WorkingDirectory
        $scriptBlockArg = $null # Initialize scriptBlockArg

        # Handle ScriptBlock parameter set
        if ($PSCmdlet.ParameterSetName -eq 'ScriptBlock') {
            # Set scriptBlockArg for C# method
            $scriptBlockArg = $ScriptBlock.ToString()
            # Arguments are handled by C# now if scriptBlock is passed
            $appPathArg = $null # C# will use powershell.exe
            $cmdLineArg = $null # C# will build the encoded command
            # Write-Host "DEBUG: Using ScriptBlock parameter set. C# will handle PowerShell execution." -ForegroundColor Cyan # Commented out
        } elseif (-not $FilePath) {
            throw "Either -FilePath or -ScriptBlock must be specified."
        }

        Write-Host "DEBUG (Invoke-AsCurrentUser): Calling StartProcessAsCurrentUser with:" -ForegroundColor Yellow # Commented out
        Write-Host "  appPath = '$appPathArg'" -ForegroundColor Yellow # Commented out
        Write-Host "  cmdLine = '$cmdLineArg'" -ForegroundColor Yellow # Commented out
        Write-Host "  workDir = '$workDirArg'" -ForegroundColor Yellow # Commented out
        Write-Host "  visible = $Visible" -ForegroundColor Yellow # Commented out
        Write-Host "  wait = $WaitTimeout" -ForegroundColor Yellow # Commented out
        Write-Host "  elevated = $Elevated" -ForegroundColor Yellow # Commented out
        Write-Host "  redirectOutput = $($CaptureOutput.IsPresent)" -ForegroundColor Yellow # Commented out
        Write-Host "  breakaway = $($BreakawayFromJob.IsPresent)" -ForegroundColor Yellow # Commented out
        # Do not log full script block here for brevity # Commented out

        # Write-Host "DEBUG: About to call C# StartProcessAsCurrentUser..." -ForegroundColor Magenta # Commented out
        $result = [RunAsUser.ProcessExtensions]::StartProcessAsCurrentUser(
            $appPathArg,
            $cmdLineArg,
            $workDirArg,
            $Visible.IsPresent, # Pass boolean based on switch presence
            $WaitTimeout,
            $Elevated.IsPresent, # Pass boolean based on switch presence
            $CaptureOutput.IsPresent,
            $BreakawayFromJob.IsPresent,
            $scriptBlockArg # Pass the script block string to C#
        )
        # Write-Host "DEBUG: C# StartProcessAsCurrentUser returned." -ForegroundColor Magenta # Commented out # Removed result logging for brevity

        # Check if C# returned a failure indicator
        if ($result -like '[FAILURE]*') {
            throw "Failed to invoke process as current user (C#): $($result -replace '^\[FAILURE\]\s*')"
        }

        # Return the result (PID if -NoWait, status message if -Wait, or captured output if -CaptureOutput)
        return $result

    } catch {
        Write-Error "Failed to invoke process as current user (PowerShell wrapper): $($_.Exception.Message)"
        # Optionally return a specific error code or object
        return "[FAILURE] PowerShell Wrapper Error: $($_.Exception.Message)"
    }
}

# Helper function (optional, could be kept private)
function Get-CurrentUserSession {
    # ... (Implementation from original runasuser.psm1 if needed) ...
    # This function might not be strictly necessary if GetSessionUserToken handles it
    Write-Warning "Get-CurrentUserSession placeholder - implement if needed"
    return $null
}

# Export the main function
Export-ModuleMember -Function Invoke-AsCurrentUser
